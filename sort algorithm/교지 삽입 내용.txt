
10가지 정렬방법이 담긴 헤더파일
1106 박정식

정보과학 교과 수업에서 정렬에 대해 배운 뒤, 본인은 이러한 정렬에 대해 조금 더 알아보고자 하여 추가로 공부해보았다.
정렬은 데이터를 특정한 조건에 따라 일정한 순서가 되도록 다시 배열하는 일을 의미한다. 즉, 목록에 포함된 원소들을 일정한 순서에 따라 재배치하는 것을 의미한다. 그 기준을 키값이라고 하며, 기준은 대표적으로 오름차순과 내림차순이 있다.
정렬 방법에는 다양한 방법이 있다. 그 이유는 상황, 값, 자료형 등에 의해 매번 적합한 방법이 다르기 때문이다. 따라서 수많은 정렬 방법이 존재한다. 이 프로그램에서는 대표적인 정렬 방법 10가지를 담았다. 또한, 이후에도 쉽게 이용할 수 있도록 헤더파일로 제작하였다.

이 헤더파일에는 10가지 정렬 함수와 그 함수를 보조하는 코드들이 포함되어 있다. 헤더파일을 추가하면 자동으로 stdio.h(표준입출력), stdlib(표준라이브러리), math(수학), memory(메모리) 헤더파일이 추가된다. sortsys 형의 bool(int, int) 함수 포인터 자료형이 제공된다. swaping의 swap 함수(define 형태)가 제공된다. temp는 swap의 대상이 될 수 없다.
ascending, decending은 각각 오름차순, 내림차순을 의미한다.

이하 함수 설명에서는 특별한 언급이 없으면 시작점, 도착점, 정렬대상, 정렬기준을 인자로 받는 것으로 간주하면 된다.

void bubbleSort(int s, int e, int a[], sortsys sos)
버블정렬은 앞에서부터 뒤로 순차적으로 인접 원소끼리 비교 후 바꿔주는 작업을 반복하는 정렬 방법이다. 시간복잡도는 O(n²)이다.

void selectionSort(int s, int e, int a[], sortsys sos)
선택정렬은 가장 작은, 혹은 큰 원소를 선택 후 앞으로 가져오는 과정을 반복하는 정렬 방법이다. 인간이 무의식적으로 사용한다. 시간복잡도는 O(n²)이다.

void insertionSort(int s, int e, int a[], sortsys sos)
삽입정렬은 원소 하나를 선택한 뒤 적당한 위치까지 앞으로 가져오는 과정을 반복하는 정렬 방법이다. 인간이 무의식적으로 사용한다. 시간복잡도는 O(n²)이다.

void quickSort(int l, int r, int d[], sortsys sos)
퀵정렬은 원소 중 하나를 기준(피벗)으로 정한 뒤, 비교를 통해 분할을 반복하는 정렬 방법으로, 분할정복의 대표적인 예시이다. 시간복잡도는 O(n log n)이다.

void heapSort(int k, int d[], sortsys sos)
힙정렬은 힙이라는 자료 구조의 특징을 이용하는 방법이다. 1부터 자료가 존재하는 배열만 사용 가능하다. 1~k까지의 자료를 정렬한다. k, 정렬대상, 정렬방법을 인자로 받는다. 시간복잡도는 O(n log n)이다. void heapify(int k, int d[], sortsys sos)는 힙을 만드는 함수, void shiftdown(int k, int m, int d[], sortsys sos)는 해당 위치에서 힙을 만족하도록 하는 함수이다.

void mergeSort(int l, int r, int d[], sortsys sos)
병합정렬은 전체를 부분으로 나눈 뒤, 합치는 과정을 통해 정렬하는 방법이다. 시간복잡도는 O(n log n)이다. void merge(int l, int m, const int r, int d[], sortsys sos) 함수는 나눈 자료를 합치는 역할을 한다.

void timSort(int l, int r, int d[], sortsys sos)
팀정렬은 일정 크기까지는 병합정렬을, 일정 크기 이하는 선택정렬을 하는 방법으로, 정렬된 것에 가까운 자료에 유리하다. 사실상 현실적인 데이터에 가장 빠른 정렬방법이다. 하이브리드 정렬에 속한다.

void countingSort(int l, int r, int d[], const int minNum, const int maxNum)
카운팅정렬은 해당 숫자가 존재하는 개수를 세는 정렬 방법으로, 중복되는 수가 많고 수의 범위가 크지 않을 때 유리하다. 정렬은 항상 내림차순이다. 시작과 끝, 정렬 대상, 가장 작은 수, 가장 큰 수를 입력받는다. 시간복잡도는 O(n+k)이다.

void bogoSort(int s, int e, int d[], sortsys sos)
보고정렬은 무작위의 순서로 값을 바꾼 다음, 정렬되었는지를 확인하는 것을 반복하는 정렬 방법이다. 기본적으로 적은 값이던 큰 값이던 비효율적이다. 이 방식은 주로 유전알고리즘에서 사용된다. 이 헤더파일은 1000개 이상의 자료를 정렬하는 것을 금지하였다.(물리적 사유로 제한되어 있다.) 시간복잡도는 O(n×n!), 최대 O(∞)이다.

void radixSort(const int start, const int end, int a[], const int base)
기수정렬은 데이터의 비교 없이 나머지 연산을 통한 수학적 성질을 이용하는 방법이다. 자릿수가 적은 정수형 자료 정렬에 유용하다. 오름차순만 가능하다. 시작위치, 끝위치, 정렬대상, 진법 순으로 입력받는다.

정렬 방법은 다양하기에, 여기서 다루지 못한 정렬(라이브러리정렬, 인트로정렬, 팬케이크정렬, 셸정렬, 대기정렬, 보고보고정렬, 칵테일쉐이크정렬, 이진삽입정렬, 이진탐색정렬, 자연병합정렬, 토너먼트정렬, 중력정렬 등)은 수없이 많다. 이는 정렬이 알고리즘의 기본이며, 자료를 정보로 만드는 첫 걸음이기 때문이다. 따라서 앞으로도 이러한 부분은 많은 연구가 진행될 것이며, 또한 많은 공부가 필요할 것이다.

※ 이 헤더파일은 다음 링크에서 MIT License로 무료로 다운로드 받을 수 있습니다.
https://github.com/sat0317/CNSH-Project/tree/master/sort%20algorithm