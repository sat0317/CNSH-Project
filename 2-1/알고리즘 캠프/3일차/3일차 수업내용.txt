1. 비트마스킹
비트로 위치 표현

2. 투포인터: 포인터를 이동시킴
p와 q 위치 지정, p위치와 q위치의 값을 더함
만약에 더한 수가 현재 원하는 값보다 큼 -> 뒤에있는걸 앞으로 밀어줌
작다면 -> 앞에있는걸 뒤로 이동
이후 한 칸씩 앞, 뒤로 이동시킨 뒤 또다시 같은 작업 반복

3. 선분교차판정: CCW
CW: 시계방향, CCW: 시계반대방향
2×S (행렬식) = (x2-x1)(y3-y1)-(y2-y1)(x3-x1)
CCW:1, CW:-1, 일직선:0

int ccw(pair<int, int> a, pair<int, int> b, pair<int, int> c){
	int op=a.first*b.second+b.first*c.second+c.first*a.second;
	op-=(a.second*b.first+b.second*c.first+c.second*a.first);
	
	if(op>0) return 1;
	else if(op==0) return 0;
	else return -1;
}

ccw(C, D, A)와 ccw(C, D, B)의 곱이 음수 -> 두 선분은 교차
예외처리: ccw(A, B, C), ccw(A, B, D)곱 또한 음수여야 함 (만나지 않는 경우도 있어서)

4. 컨벡스헐: 볼록껍질(볼록다각형찾기)
first, second 맨 밖에 찾고(x값 가장 큰거끼리라던가 등등 맨 밖인거 확실한거)
그다음으로 ccw 한 점을 잡고, 그다음점을 잡으며 stack으로 사용
ccw가 아니라 cw가 등장하면 추가하지 않고
ccw이면 추가
